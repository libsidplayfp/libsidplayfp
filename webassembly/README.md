# libsidplayfp WebAssembly Tooling

This folder contains a self-contained Docker workflow that builds
`libsidplayfp` to WebAssembly using Emscripten and generates a JavaScript
module with TypeScript typings. The resulting bundle exposes a
`SidPlayerContext` class that lets you drive the SID emulator from modern
TypeScript projects.

## Prerequisites

- Docker installed and available on your PATH.
- Internet access (the Docker build downloads Emscripten and clones the
  upstream `libsidplayfp` repository).

## Usage

From the repository root (or directly inside this folder) run:

```bash
./webassembly/build.sh
```

The script will:

1. Build the Docker image defined in `Dockerfile` (Ubuntu 24.04 + emsdk).
2. Run the container, which clones `https://github.com/libsidplayfp/libsidplayfp`,
   applies the thread guard script described below, and compiles the
   library together with the embind bindings in `bindings.cpp`.
3. Drop the generated artifacts into `webassembly/dist/` on the host.

The output directory contains:

- `libsidplayfp.js` – ES module wrapper generated by Emscripten.
- `libsidplayfp.wasm` – WebAssembly binary.
- `libsidplayfp.d.ts` – TypeScript declarations for the embind API.
- `package.json` – Minimal metadata so you can publish or consume the bundle
  as an npm package.
- `README.md` – Quick-start instructions for importing the module.
- `LICENSE` – Upstream project license.

### Thread guard automation

Upstream LUT builders spawn helper threads while precomputing filter
tables. Browsers (and most Node.js WASM hosts) run without pthreads, so the
Docker entrypoint invokes `webassembly/scripts/apply_thread_guards.py`
immediately after cloning. The script scans every `FilterModelConfig*.cpp`
file, finds the `sidThread` launches, and injects an
`#if defined(__EMSCRIPTEN__)` branch that calls the lambdas sequentially.
Because the script derives the lambda list from the source it is
idempotent and resilient to upstream refactors—native builds remain
unchanged.

## Bun Demo

To see the module in action from TypeScript, a Bun-based example lives in
`webassembly/demo/`. After building the WebAssembly bundle you can export the
provided HVSC tune to WAV:

```bash
bun run webassembly/demo/demo.ts \
  Test.sid \
  Test.wav \
  90
```

The script instantiates the WebAssembly player, renders the requested duration,
and writes a 16-bit stereo PCM WAV file.

## Using the Bundle

After running the build you can import the module in any TypeScript/ESM
project:

```ts
import createLibsidplayfp from "./libsidplayfp.js";

const module = await createLibsidplayfp();
const player = new module.SidPlayerContext();
```

Load SID data via the provided helpers (`loadSidBuffer`, `loadSidFile`) and
call `render` to obtain PCM samples (`Int16Array`). The bindings expose
metadata helpers (`getTuneInfo`, `getEngineInfo`) and configuration knobs.

When loading files by filename, ensure the data is present in Emscripten's
virtual filesystem (e.g. by mounting with `FS.writeFile`). For browser use,
prefer `loadSidBuffer` with an `ArrayBuffer`/`Uint8Array`.

## Notes

- The build disables pthreads to keep the output compatible with browsers that
  do not opt into SharedArrayBuffer/COOP+COEP requirements.
- If you need additional exports or configuration flags, edit `bindings.cpp`
  and rebuild.
- The Docker image is reusable; subsequent runs will rebuild only the library
  inside the container.
